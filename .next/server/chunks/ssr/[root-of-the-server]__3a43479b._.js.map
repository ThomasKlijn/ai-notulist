{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/server/audioStorage.ts"],"sourcesContent":["// Temporary file-based audio storage for deployment compatibility\n// Replaces Replit-specific object storage\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { promisify } from 'util';\n\nconst writeFile = promisify(fs.writeFile);\nconst readFile = promisify(fs.readFile);\nconst unlink = promisify(fs.unlink);\nconst mkdir = promisify(fs.mkdir);\nconst readdir = promisify(fs.readdir);\n\ninterface AudioChunk {\n  meetingId: string;\n  chunkIndex: number;\n  filePath: string;\n  timestamp: Date;\n}\n\nclass TemporaryFileAudioStorage {\n  private chunks: Map<string, AudioChunk> = new Map();\n  private tempDir: string;\n\n  constructor() {\n    // Use /tmp directory for temporary audio storage\n    this.tempDir = path.join('/tmp', 'audio-chunks');\n    this.ensureTempDirectory();\n  }\n\n  private async ensureTempDirectory(): Promise<void> {\n    try {\n      await mkdir(this.tempDir, { recursive: true });\n    } catch (error) {\n      // Directory might already exist, that's ok\n    }\n  }\n\n  // Generate key for storing chunks\n  private getChunkKey(meetingId: string, chunkIndex: number): string {\n    return `${meetingId}-chunk-${chunkIndex}`;\n  }\n\n  // Generate file path for chunk\n  private getChunkFilePath(meetingId: string, chunkIndex: number): string {\n    return path.join(this.tempDir, `${meetingId}-chunk-${chunkIndex}.webm`);\n  }\n\n  // Upload an audio chunk to temporary file\n  async uploadAudioChunk(meetingId: string, chunkIndex: number, audioBuffer: Buffer): Promise<string> {\n    try {\n      console.log(`Storing audio chunk ${chunkIndex} for meeting ${meetingId}, size: ${audioBuffer.length} bytes`);\n      \n      await this.ensureTempDirectory();\n      \n      const chunkKey = this.getChunkKey(meetingId, chunkIndex);\n      const filePath = this.getChunkFilePath(meetingId, chunkIndex);\n      \n      // Write buffer to temporary file\n      await writeFile(filePath, audioBuffer);\n      \n      const chunk: AudioChunk = {\n        meetingId,\n        chunkIndex,\n        filePath,\n        timestamp: new Date()\n      };\n\n      this.chunks.set(chunkKey, chunk);\n      console.log(`Successfully stored chunk ${chunkIndex} to file: ${filePath}`);\n      \n      return chunkKey; // Return key as the \"path\"\n    } catch (error: any) {\n      console.error(`Error storing audio chunk ${chunkIndex}:`, error);\n      throw new Error(`Failed to store audio chunk: ${error?.message || error}`);\n    }\n  }\n\n  // Download an audio chunk from temporary file\n  async downloadAudioChunk(chunkKey: string): Promise<Buffer> {\n    console.log(`üì• Downloading audio chunk: ${chunkKey}`);\n    \n    // Parse meetingId and chunkIndex from chunkKey\n    const parts = chunkKey.split('-chunk-');\n    if (parts.length !== 2) {\n      throw new Error(`Invalid chunk key format: ${chunkKey}`);\n    }\n    \n    const meetingId = parts[0];\n    const chunkIndex = parseInt(parts[1]);\n    const filePath = this.getChunkFilePath(meetingId, chunkIndex);\n    \n    console.log(`üîç Looking for file: ${filePath}`);\n    \n    try {\n      // Always read directly from file system (ignore in-memory Map which gets reset after restart)\n      if (fs.existsSync(filePath)) {\n        console.log(`‚úÖ Found and reading chunk file: ${filePath}`);\n        const buffer = await readFile(filePath);\n        console.log(`‚úÖ Successfully read chunk ${chunkIndex}, size: ${buffer.length} bytes`);\n        return buffer;\n      } else {\n        console.error(`‚ùå Audio chunk file not found at: ${filePath}`);\n        \n        // Debug: Check what files exist for this meeting\n        try {\n          const files = await readdir(this.tempDir);\n          const meetingFiles = files.filter(f => f.includes(meetingId));\n          console.log(`üîç Available files for meeting ${meetingId}:`, meetingFiles);\n        } catch (e) {\n          console.error(`‚ùå Could not read temp directory ${this.tempDir}`);\n        }\n        \n        throw new Error(`Audio chunk file not found: ${filePath}`);\n      }\n    } catch (error: any) {\n      console.error(`‚ùå Failed to read audio chunk ${chunkKey}:`, error);\n      throw new Error(`Failed to read audio chunk: ${error?.message || error}`);\n    }\n  }\n\n  // Get all audio chunks for a meeting\n  async getAllAudioChunksForMeeting(meetingId: string): Promise<Buffer[]> {\n    console.log(`Getting all audio chunks for meeting: ${meetingId}`);\n    \n    // Read directly from file system instead of relying on in-memory Map\n    // (which gets reset after server restart)\n    const buffers: Buffer[] = [];\n    \n    try {\n      const files = await readdir(this.tempDir);\n      const chunkFiles = files\n        .filter(file => file.startsWith(`${meetingId}-chunk-`) && file.endsWith('.webm'))\n        .map(file => {\n          const match = file.match(new RegExp(`^${meetingId}-chunk-(\\\\d+)\\\\.webm$`));\n          return match ? { \n            file, \n            chunkIndex: parseInt(match[1]),\n            filePath: path.join(this.tempDir, file)\n          } : null;\n        })\n        .filter(Boolean)\n        .sort((a, b) => a!.chunkIndex - b!.chunkIndex);\n\n      console.log(`Found ${chunkFiles.length} chunk files for meeting ${meetingId}`);\n      \n      for (const chunkFile of chunkFiles) {\n        if (chunkFile && fs.existsSync(chunkFile.filePath)) {\n          try {\n            const buffer = await readFile(chunkFile.filePath);\n            buffers.push(buffer);\n            console.log(`‚úÖ Read chunk ${chunkFile.chunkIndex}: ${buffer.length} bytes`);\n          } catch (error) {\n            console.error(`Error reading chunk file ${chunkFile.filePath}:`, error);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(`Error reading temp directory ${this.tempDir}:`, error);\n    }\n    \n    console.log(`Total chunks loaded: ${buffers.length}`);\n    return buffers;\n  }\n\n  // Combine audio chunks into a single buffer for transcription\n  async combineAudioChunks(meetingId: string): Promise<Buffer> {\n    const chunks = await this.getAllAudioChunksForMeeting(meetingId);\n    return Buffer.concat(chunks);\n  }\n\n  // Get first audio chunk for transcription (since WebM chunks can't be concatenated)\n  async getFirstAudioChunk(meetingId: string): Promise<Buffer | null> {\n    const firstChunkKey = this.getChunkKey(meetingId, 0);\n    console.log(`Looking for first audio chunk: ${firstChunkKey}`);\n    \n    try {\n      const buffer = await this.downloadAudioChunk(firstChunkKey);\n      console.log(`Successfully found first audio chunk, size: ${buffer.length} bytes`);\n      return buffer;\n    } catch (error) {\n      console.log(`First audio chunk not found for meeting ${meetingId}:`, error);\n      return null;\n    }\n  }\n\n  // Clean up chunks for a meeting (optional - for memory management)\n  async cleanupMeetingChunks(meetingId: string): Promise<void> {\n    const keysToDelete: string[] = [];\n    const filesToDelete: string[] = [];\n    \n    for (const [key, chunk] of this.chunks.entries()) {\n      if (chunk.meetingId === meetingId) {\n        keysToDelete.push(key);\n        filesToDelete.push(chunk.filePath);\n      }\n    }\n\n    // Delete files\n    for (const filePath of filesToDelete) {\n      try {\n        if (fs.existsSync(filePath)) {\n          await unlink(filePath);\n        }\n      } catch (error) {\n        console.error(`Error deleting file ${filePath}:`, error);\n      }\n    }\n\n    // Remove from memory map\n    keysToDelete.forEach(key => this.chunks.delete(key));\n    console.log(`Cleaned up ${keysToDelete.length} chunks for meeting ${meetingId}`);\n  }\n\n  // Get storage stats\n  getStorageStats(): { totalChunks: number; totalFileSizeMB: number } {\n    let totalBytes = 0;\n    let validChunks = 0;\n    \n    for (const chunk of this.chunks.values()) {\n      try {\n        if (fs.existsSync(chunk.filePath)) {\n          const stats = fs.statSync(chunk.filePath);\n          totalBytes += stats.size;\n          validChunks++;\n        }\n      } catch (error) {\n        // File might not exist anymore\n      }\n    }\n    \n    return {\n      totalChunks: validChunks,\n      totalFileSizeMB: Math.round(totalBytes / (1024 * 1024) * 100) / 100\n    };\n  }\n}\n\n// Export singleton instance\nexport const audioStorage = new TemporaryFileAudioStorage();\n\n// Export class for compatibility with existing ObjectStorageService interface\nexport class AudioStorageService {\n  async uploadAudioChunk(meetingId: string, chunkIndex: number, audioBuffer: Buffer): Promise<string> {\n    return audioStorage.uploadAudioChunk(meetingId, chunkIndex, audioBuffer);\n  }\n\n  async downloadAudioChunk(chunkKey: string): Promise<Buffer> {\n    return audioStorage.downloadAudioChunk(chunkKey);\n  }\n\n  async getAllAudioChunksForMeeting(meetingId: string): Promise<Buffer[]> {\n    return audioStorage.getAllAudioChunksForMeeting(meetingId);\n  }\n\n  async combineAudioChunks(meetingId: string): Promise<Buffer> {\n    return audioStorage.combineAudioChunks(meetingId);\n  }\n\n  async getFirstAudioChunk(meetingId: string): Promise<Buffer | null> {\n    return audioStorage.getFirstAudioChunk(meetingId);\n  }\n}"],"names":[],"mappings":"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","debugId":null}}]
}