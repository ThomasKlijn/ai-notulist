{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/server/elevenlabs.ts"],"sourcesContent":["// ElevenLabs Scribe Speech-to-Text Integration\n// More accurate than OpenAI Whisper (96.7% vs ~90-95%)\n\nexport interface ElevenLabsWord {\n  text: string;\n  start: number;\n  end: number;\n  speaker?: string;\n}\n\nexport interface ElevenLabsSpeaker {\n  speaker_id: string;\n  start: number;\n  end: number;\n}\n\nexport interface ElevenLabsTranscription {\n  language_code: string;\n  language_probability: number;\n  text: string;\n  words?: ElevenLabsWord[];\n  speakers?: ElevenLabsSpeaker[];\n}\n\n// Transcribe audio buffer using ElevenLabs Scribe (world's most accurate STT)\nexport async function transcribeAudioWithElevenLabs(\n  audioBuffer: Buffer, \n  language: string = 'nl'\n): Promise<string> {\n  try {\n    console.log(`üéôÔ∏è [ElevenLabs] Transcribing audio: ${audioBuffer.length} bytes, language: ${language}`);\n    \n    if (!process.env.ELEVENLABS_API_KEY) {\n      throw new Error('ElevenLabs API key not found in environment variables');\n    }\n\n    // Convert language code for ElevenLabs (they use ISO codes)\n    const languageCode = language === 'nl' ? 'nl' : 'en';\n    \n    // Create FormData for the API request\n    const formData = new FormData();\n    \n    // Create a blob from the audio buffer (convert Buffer to Uint8Array for Node.js compatibility)\n    const audioBlob = new Blob([new Uint8Array(audioBuffer)], { type: 'audio/webm' });\n    const audioFile = new File([audioBlob], 'recording.webm', { type: 'audio/webm' });\n    \n    formData.append('file', audioFile);\n    formData.append('model_id', 'scribe_v1'); // Back to standard model\n    formData.append('language_code', languageCode);\n    formData.append('diarize', 'true'); // Enable speaker identification\n    formData.append('tag_audio_events', 'true'); // Detect laughter, applause, etc. (correct parameter name)\n    formData.append('timestamps_granularity', 'word'); // Word-level timestamps\n    \n    console.log(`üöÄ [ElevenLabs] Sending request to Scribe API...`);\n    console.log(`üîë [ElevenLabs] API Key configured: ${!!process.env.ELEVENLABS_API_KEY}`);\n    console.log(`üìä [ElevenLabs] File size: ${audioBuffer.length} bytes`);\n    console.log(`üìä [ElevenLabs] Language: ${languageCode}`);\n    console.log(`üìä [ElevenLabs] Model: scribe_v1`);\n    \n    const response = await fetch('https://api.elevenlabs.io/v1/speech-to-text', {\n      method: 'POST',\n      headers: {\n        'xi-api-key': process.env.ELEVENLABS_API_KEY,\n      },\n      body: formData,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(`‚ùå [ElevenLabs] API Error (${response.status}):`, errorText);\n      throw new Error(`ElevenLabs API error: ${response.status} - ${errorText}`);\n    }\n\n    const result: ElevenLabsTranscription = await response.json();\n    \n    console.log(`‚úÖ [ElevenLabs] Transcription complete:`);\n    console.log(`   - Language: ${result.language_code} (${Math.round(result.language_probability * 100)}% confidence)`);\n    console.log(`   - Characters: ${result.text.length}`);\n    console.log(`   - Speakers detected: ${result.speakers?.length || 0}`);\n    console.log(`   - Words with timestamps: ${result.words?.length || 0}`);\n    \n    // Enhanced logging with speaker information\n    if (result.speakers && result.speakers.length > 0) {\n      console.log(`üë• [ElevenLabs] Speakers identified:`);\n      result.speakers.forEach((speaker, index) => {\n        const duration = Math.round(speaker.end - speaker.start);\n        console.log(`   - ${speaker.speaker_id}: ${duration}s (${speaker.start}s - ${speaker.end}s)`);\n      });\n    }\n\n    const cleanText = result.text.trim();\n    console.log(`üìù [ElevenLabs] Sample: \"${cleanText.substring(0, 100)}...\"`);\n    \n    return cleanText;\n  } catch (error: any) {\n    console.error('‚ùå [ElevenLabs] Error transcribing audio:', error);\n    \n    // Enhanced error context\n    if (error.message?.includes('API key')) {\n      throw new Error('ElevenLabs API key is missing or invalid');\n    } else if (error.message?.includes('quota') || error.message?.includes('limit')) {\n      throw new Error('ElevenLabs API quota exceeded - check your billing');\n    } else if (error.message?.includes('file') || error.message?.includes('format')) {\n      throw new Error('Audio file format not supported by ElevenLabs Scribe');\n    }\n    \n    throw new Error('Failed to transcribe audio with ElevenLabs: ' + (error?.message || error));\n  }\n}\n\n// Enhanced transcription with speaker analysis (for future meeting insights)\nexport async function transcribeWithSpeakerAnalysis(\n  audioBuffer: Buffer, \n  language: string = 'nl'\n): Promise<{\n  text: string;\n  speakers: Array<{\n    id: string;\n    duration: number;\n    percentage: number;\n  }>;\n  totalDuration: number;\n}> {\n  try {\n    console.log(`üéôÔ∏è [ElevenLabs] Starting enhanced transcription with speaker analysis...`);\n    \n    if (!process.env.ELEVENLABS_API_KEY) {\n      throw new Error('ElevenLabs API key not found');\n    }\n\n    const languageCode = language === 'nl' ? 'nl' : 'en';\n    \n    const formData = new FormData();\n    const audioBlob = new Blob([new Uint8Array(audioBuffer)], { type: 'audio/webm' });\n    const audioFile = new File([audioBlob], 'recording.webm', { type: 'audio/webm' });\n    \n    formData.append('file', audioFile);\n    formData.append('model_id', 'scribe_v1'); // Back to standard model\n    formData.append('language_code', languageCode);\n    formData.append('diarize', 'true');\n    formData.append('tag_audio_events', 'true');\n    formData.append('timestamps_granularity', 'word');\n    \n    const response = await fetch('https://api.elevenlabs.io/v1/speech-to-text', {\n      method: 'POST',\n      headers: {\n        'xi-api-key': process.env.ELEVENLABS_API_KEY,\n      },\n      body: formData,\n    });\n\n    if (!response.ok) {\n      throw new Error(`ElevenLabs API error: ${response.status}`);\n    }\n\n    const result: ElevenLabsTranscription = await response.json();\n    \n    // Calculate speaker statistics\n    const speakers = result.speakers?.map(speaker => {\n      const duration = speaker.end - speaker.start;\n      return {\n        id: speaker.speaker_id,\n        duration: Math.round(duration * 10) / 10, // Round to 1 decimal\n        start: speaker.start,\n        end: speaker.end\n      };\n    }) || [];\n    \n    const totalDuration = speakers.length > 0 \n      ? Math.max(...speakers.map(s => s.end)) \n      : 0;\n    \n    const speakersWithPercentage = speakers.map(speaker => ({\n      id: speaker.id,\n      duration: speaker.duration,\n      percentage: totalDuration > 0 ? Math.round((speaker.duration / totalDuration) * 100) : 0\n    }));\n    \n    console.log(`‚úÖ [ElevenLabs] Enhanced transcription complete with ${speakers.length} speakers`);\n    \n    return {\n      text: result.text.trim(),\n      speakers: speakersWithPercentage,\n      totalDuration: Math.round(totalDuration * 10) / 10\n    };\n    \n  } catch (error: any) {\n    console.error('‚ùå [ElevenLabs] Enhanced transcription failed:', error);\n    \n    // Fallback to basic transcription\n    const basicText = await transcribeAudioWithElevenLabs(audioBuffer, language);\n    return {\n      text: basicText,\n      speakers: [],\n      totalDuration: 0\n    };\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/server/openai.ts"],"sourcesContent":["import OpenAI from \"openai\";\n\n// Using GPT-4o which is the most capable model currently available\nconst openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n\nexport interface MeetingSummary {\n  title: string;\n  generalSummary: string;\n  keyPoints: string[];\n  decisions: string[];\n  actionItems: Array<{\n    task: string;\n    assignee?: string;\n    dueDate?: string;\n  }>;\n  participants: string[];\n  duration: string;\n  nextSteps?: string[];\n}\n\n// Import ElevenLabs Scribe for superior transcription accuracy\nimport { transcribeAudioWithElevenLabs } from './elevenlabs';\n\n// Main transcription function - try ElevenLabs first, fallback to Whisper\nexport async function transcribeAudio(audioBuffer: Buffer, language: string = 'nl'): Promise<string> {\n  try {\n    console.log('üéØ Attempting ElevenLabs Scribe transcription first...');\n    return await transcribeAudioWithElevenLabs(audioBuffer, language);\n  } catch (elevenlabsError: any) {\n    console.warn('‚ö†Ô∏è ElevenLabs failed, falling back to OpenAI Whisper:', elevenlabsError.message);\n    console.log('üîÑ Using OpenAI Whisper as fallback...');\n    return await transcribeAudioWithWhisper(audioBuffer, language);\n  }\n}\n\n// Legacy OpenAI Whisper function (kept as fallback)\nexport async function transcribeAudioWithWhisper(audioBuffer: Buffer, language: string = 'nl'): Promise<string> {\n  try {\n    console.log(`üéôÔ∏è [Whisper Fallback] Transcribing audio: ${audioBuffer.length} bytes, language: ${language}`);\n    \n    // Create a File-like object from the buffer\n    const audioBlob = new Blob([new Uint8Array(audioBuffer)], { type: 'audio/webm' });\n    const audioFile = new File([audioBlob], 'recording.webm', { type: 'audio/webm' });\n\n    const isEnglish = language === 'en';\n    const promptText = isEnglish \n      ? \"This is a business meeting recording. Please transcribe clearly with proper punctuation and capitalization.\"\n      : \"Dit is een zakelijke meeting opname. Transcribeer duidelijk met juiste interpunctie en hoofdletters.\";\n\n    const transcription = await openai.audio.transcriptions.create({\n      file: audioFile,\n      model: \"whisper-1\",\n      language: language === 'nl' ? 'nl' : 'en',\n      response_format: \"verbose_json\", // Get detailed response with segments\n      temperature: 0, // More deterministic results\n      prompt: promptText, // Context for better recognition\n    });\n\n    // Extract text from verbose response\n    let fullText = '';\n    if (transcription.segments && Array.isArray(transcription.segments)) {\n      // Use segments for better text quality\n      fullText = transcription.segments\n        .map((segment: any) => segment.text?.trim())\n        .filter(Boolean)\n        .join(' ');\n    } else {\n      // Fallback to main text\n      fullText = transcription.text || '';\n    }\n\n    const cleanText = fullText.trim();\n    console.log(`‚úÖ [Whisper] Transcribed ${cleanText.length} characters: \"${cleanText.substring(0, 100)}...\"`);\n    \n    return cleanText;\n  } catch (error: any) {\n    console.error('‚ùå [Whisper] Error transcribing audio:', error);\n    throw new Error('Failed to transcribe audio with Whisper: ' + (error?.message || error));\n  }\n}\n\n// Generate meeting summary using GPT-5\nexport async function generateMeetingSummary(\n  transcription: string, \n  meetingTitle: string,\n  language: string = 'nl'\n): Promise<MeetingSummary> {\n  try {\n    const isEnglish = language === 'en';\n    \n    const prompt = isEnglish \n      ? `Please analyze this meeting transcription and provide a structured summary in JSON format with the following structure:\n\n{\n  \"title\": \"Meeting title/subject\",\n  \"generalSummary\": \"A comprehensive 2-3 sentence overview of what was discussed in the meeting\",\n  \"keyPoints\": [\"List of key discussion points\"],\n  \"decisions\": [\"Decisions made during the meeting\"],\n  \"actionItems\": [{\"task\": \"Description\", \"assignee\": \"Person name if mentioned\", \"dueDate\": \"Date if mentioned\"}],\n  \"participants\": [\"Names of people mentioned in the meeting\"],\n  \"duration\": \"Estimated meeting duration\",\n  \"nextSteps\": [\"Next steps or follow-up actions\"]\n}\n\nMeeting Title: ${meetingTitle}\nTranscription: ${transcription}`\n      : `Analyseer deze meeting transcriptie en geef een gestructureerde samenvatting in JSON formaat met de volgende structuur:\n\n{\n  \"title\": \"Meeting titel/onderwerp\",\n  \"generalSummary\": \"Een uitgebreide samenvatting van 2-3 zinnen over wat er besproken is in de meeting\",\n  \"keyPoints\": [\"Lijst van belangrijke discussiepunten\"],\n  \"decisions\": [\"Beslissingen genomen tijdens de meeting\"],\n  \"actionItems\": [{\"task\": \"Beschrijving\", \"assignee\": \"Persoon naam indien genoemd\", \"dueDate\": \"Datum indien genoemd\"}],\n  \"participants\": [\"Namen van personen genoemd in de meeting\"],\n  \"duration\": \"Geschatte meeting duur\",\n  \"nextSteps\": [\"Volgende stappen of vervolgacties\"]\n}\n\nMeeting Titel: ${meetingTitle}\nTranscriptie: ${transcription}`;\n\n    const response = await openai.chat.completions.create({\n      model: \"gpt-4o\",\n      messages: [\n        {\n          role: \"system\",\n          content: isEnglish \n            ? \"You are an expert meeting assistant. Analyze meeting transcriptions and provide structured, accurate summaries. Always respond with valid JSON.\"\n            : \"Je bent een expert meeting assistent. Analyseer meeting transcripties en geef gestructureerde, nauwkeurige samenvattingen. Antwoord altijd met geldige JSON.\"\n        },\n        {\n          role: \"user\",\n          content: prompt,\n        },\n      ],\n      response_format: { type: \"json_object\" },\n    });\n\n    const result = JSON.parse(response.choices[0].message.content || '{}');\n    return result as MeetingSummary;\n  } catch (error: any) {\n    console.error('Error generating meeting summary:', error);\n    throw new Error('Failed to generate meeting summary: ' + (error?.message || error));\n  }\n}"],"names":[],"mappings":";;;;;;;;AAAA;AAoBA,+DAA+D;AAC/D;;AAnBA,mEAAmE;AACnE,MAAM,SAAS,IAAI,6JAAM,CAAC;IAAE,QAAQ,QAAQ,GAAG,CAAC,cAAc;AAAC;;AAqBxD,eAAe,gBAAgB,WAAmB,EAAE,WAAmB,IAAI;IAChF,IAAI;QACF,QAAQ,GAAG,CAAC;QACZ,OAAO,MAAM,IAAA,uJAA6B,EAAC,aAAa;IAC1D,EAAE,OAAO,iBAAsB;QAC7B,QAAQ,IAAI,CAAC,yDAAyD,gBAAgB,OAAO;QAC7F,QAAQ,GAAG,CAAC;QACZ,OAAO,MAAM,2BAA2B,aAAa;IACvD;AACF;AAGO,eAAe,2BAA2B,WAAmB,EAAE,WAAmB,IAAI;IAC3F,IAAI;QACF,QAAQ,GAAG,CAAC,CAAC,2CAA2C,EAAE,YAAY,MAAM,CAAC,kBAAkB,EAAE,UAAU;QAE3G,4CAA4C;QAC5C,MAAM,YAAY,IAAI,KAAK;YAAC,IAAI,WAAW;SAAa,EAAE;YAAE,MAAM;QAAa;QAC/E,MAAM,YAAY,IAAI,KAAK;YAAC;SAAU,EAAE,kBAAkB;YAAE,MAAM;QAAa;QAE/E,MAAM,YAAY,aAAa;QAC/B,MAAM,aAAa,YACf,gHACA;QAEJ,MAAM,gBAAgB,MAAM,OAAO,KAAK,CAAC,cAAc,CAAC,MAAM,CAAC;YAC7D,MAAM;YACN,OAAO;YACP,UAAU,aAAa,OAAO,OAAO;YACrC,iBAAiB;YACjB,aAAa;YACb,QAAQ;QACV;QAEA,qCAAqC;QACrC,IAAI,WAAW;QACf,IAAI,cAAc,QAAQ,IAAI,MAAM,OAAO,CAAC,cAAc,QAAQ,GAAG;YACnE,uCAAuC;YACvC,WAAW,cAAc,QAAQ,CAC9B,GAAG,CAAC,CAAC,UAAiB,QAAQ,IAAI,EAAE,QACpC,MAAM,CAAC,SACP,IAAI,CAAC;QACV,OAAO;YACL,wBAAwB;YACxB,WAAW,cAAc,IAAI,IAAI;QACnC;QAEA,MAAM,YAAY,SAAS,IAAI;QAC/B,QAAQ,GAAG,CAAC,CAAC,wBAAwB,EAAE,UAAU,MAAM,CAAC,cAAc,EAAE,UAAU,SAAS,CAAC,GAAG,KAAK,IAAI,CAAC;QAEzG,OAAO;IACT,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,yCAAyC;QACvD,MAAM,IAAI,MAAM,8CAA8C,CAAC,OAAO,WAAW,KAAK;IACxF;AACF;AAGO,eAAe,uBACpB,aAAqB,EACrB,YAAoB,EACpB,WAAmB,IAAI;IAEvB,IAAI;QACF,MAAM,YAAY,aAAa;QAE/B,MAAM,SAAS,YACX,CAAC;;;;;;;;;;;;;eAaM,EAAE,aAAa;eACf,EAAE,eAAe,GACxB,CAAC;;;;;;;;;;;;;eAaM,EAAE,aAAa;cAChB,EAAE,eAAe;QAE3B,MAAM,WAAW,MAAM,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;YACpD,OAAO;YACP,UAAU;gBACR;oBACE,MAAM;oBACN,SAAS,YACL,oJACA;gBACN;gBACA;oBACE,MAAM;oBACN,SAAS;gBACX;aACD;YACD,iBAAiB;gBAAE,MAAM;YAAc;QACzC;QAEA,MAAM,SAAS,KAAK,KAAK,CAAC,SAAS,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,IAAI;QACjE,OAAO;IACT,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,qCAAqC;QACnD,MAAM,IAAI,MAAM,yCAAyC,CAAC,OAAO,WAAW,KAAK;IACnF;AACF","debugId":null}},
    {"offset": {"line": 327, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/server/processingService.ts"],"sourcesContent":["import { storage } from './storage';\nimport { transcribeAudio, generateMeetingSummary } from './openai';\nimport { transcribeWithSpeakerAnalysis } from './elevenlabs';\nimport type { MeetingSummary } from './openai';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { promisify } from 'util';\n\nconst readdir = promisify(fs.readdir);\nconst readFile = promisify(fs.readFile);\nconst unlink = promisify(fs.unlink);\n\nexport class MeetingProcessingService {\n  private processingQueue: Map<string, Promise<void>> = new Map();\n  private processingChain: Promise<void> = Promise.resolve(); // Serialize all processing\n  private cleanupInterval?: NodeJS.Timeout;\n\n  constructor() {\n    // No longer using AudioStorageService - we work directly with temp files\n    // Schedule periodic cleanup every 6 hours\n    this.cleanupInterval = setInterval(() => {\n      // Clean orphaned audio chunks\n      this.cleanupOrphanedChunks(24).catch(err => \n        console.error('Periodic orphaned chunks cleanup failed:', err)\n      );\n      \n      // Clean old meetings according to retention policy\n      this.runAutoCleanup().catch(err => \n        console.error('Periodic meeting cleanup failed:', err)\n      );\n    }, 6 * 60 * 60 * 1000); // 6 hours\n  }\n\n  // Process a finished meeting: transcribe audio and generate summary (strict serialization)\n  async processMeeting(meetingId: string): Promise<void> {\n    // Check if already processing this meeting\n    if (this.processingQueue.has(meetingId)) {\n      console.log(`‚ö†Ô∏è Meeting ${meetingId} is already being processed`);\n      return this.processingQueue.get(meetingId)!;\n    }\n    \n    // STRICT SERIALIZATION: Chain all processing to guarantee max 1 at a time\n    const processingPromise = this.processingChain.then(async () => {\n      console.log(`üöÄ Starting serialized processing for meeting ${meetingId}`);\n      return this.doProcessMeeting(meetingId);\n    }).finally(() => {\n      // Clean up from queue when done\n      this.processingQueue.delete(meetingId);\n      console.log(`‚úÖ Serialized processing completed for ${meetingId}`);\n    });\n    \n    // Add to queue and update chain\n    this.processingQueue.set(meetingId, processingPromise);\n    this.processingChain = processingPromise.catch(() => {}); // Continue chain even on errors\n    \n    return processingPromise;\n  }\n  \n  // Internal processing method\n  private async doProcessMeeting(meetingId: string): Promise<void> {\n    try {\n      console.log(`Starting processing for meeting ${meetingId}`);\n      \n      // Get meeting details\n      const meeting = await storage.getMeetingWithAttendees(meetingId);\n      if (!meeting) {\n        throw new Error(`Meeting ${meetingId} not found`);\n      }\n\n      // GDPR: Check consent before starting processing (organizer consent given on behalf of all)\n      if (!meeting.organizerConsentGiven || meeting.status === 'cancelled') {\n        console.log(`‚ùå GDPR: Cannot process meeting ${meetingId} - missing organizer consent or cancelled status`);\n        await storage.updateMeeting(meetingId, { \n          status: 'failed',\n          summary: { error: 'Processing stopped due to missing consent or withdrawal' } as any\n        });\n        return;\n      }\n\n      // Update status to processing\n      await storage.updateMeeting(meetingId, { status: 'processing' });\n\n      // GDPR: Re-check consent before expensive transcription\n      const consentCheck1 = await storage.getMeeting(meetingId);\n      if (consentCheck1?.status === 'cancelled') {\n        console.log(`‚ùå GDPR: Processing halted during transcription phase - meeting cancelled`);\n        return;\n      }\n\n      // MEMORY-OPTIMIZED: Transcribe chunks sequentially WITH SPEAKER DIARIZATION\n      console.log('üéØ OPTIMIZED: Processing audio chunks sequentially with speaker analysis...');\n      const { transcription, speakers } = await this.transcribeChunksWithSpeakers(meetingId, meeting.language || 'nl');\n      if (!transcription || transcription.length === 0) {\n        throw new Error('No audio data found for transcription');\n      }\n      \n      console.log(`‚úÖ Sequential transcription completed (${transcription.length} chars): ${transcription.substring(0, 100)}...`);\n      console.log(`üë• Speaker analysis: ${speakers.length} speakers detected`);\n      \n      // Save speaker data to database\n      if (speakers.length > 0) {\n        await storage.addSpeakers(meetingId, speakers.map(speaker => ({\n          speakerId: speaker.id,\n          duration: Math.round(speaker.duration),\n          percentage: speaker.percentage\n        })));\n        \n        // Also store raw speaker data as JSONB\n        await storage.updateMeeting(meetingId, { speakerData: speakers as any });\n        console.log(`üë• Saved ${speakers.length} speakers to database`);\n      }\n      \n      // GDPR: Re-check consent before AI summary generation\n      const consentCheck2 = await storage.getMeeting(meetingId);\n      if (consentCheck2?.status === 'cancelled') {\n        console.log(`‚ùå GDPR: Processing halted during AI summary phase - meeting cancelled`);\n        return;\n      }\n\n      // Generate summary\n      console.log('Generating AI summary...');\n      const summary = await generateMeetingSummary(\n        transcription, \n        meeting.title, \n        meeting.language || 'nl'\n      );\n\n      // Update meeting with results\n      await storage.updateMeeting(meetingId, {\n        status: 'completed',\n        transcription: transcription,\n        summary: summary as any, // Store as JSONB\n      });\n\n      console.log(`Meeting ${meetingId} processing completed successfully`);\n      \n      // Final cleanup of any remaining chunk files\n      await this.forceCleanupMeetingChunks(meetingId);\n\n      // GDPR: Final consent check before email delivery\n      const consentCheck3 = await storage.getMeeting(meetingId);\n      if (consentCheck3?.status === 'cancelled') {\n        console.log(`‚ùå GDPR: Email delivery halted - meeting cancelled`);\n        return;\n      }\n\n      // Send email summary to attendees (refetch meeting with speakers)\n      console.log(`Starting email delivery for meeting ${meetingId} to ${meeting.attendees.length} attendees`);\n      const meetingWithSpeakers = await storage.getMeetingWithAttendees(meetingId);\n      await this.sendEmailSummary(meetingWithSpeakers || meeting, transcription, summary);\n\n    } catch (error: any) {\n      console.error(`Error processing meeting ${meetingId}:`, error);\n      \n      // Mark as failed\n      await storage.updateMeeting(meetingId, { \n        status: 'failed',\n        summary: { error: error.message } as any\n      });\n      \n      throw error;\n    }\n  }\n\n  // Memory-optimized: Process chunks sequentially WITH SPEAKER DIARIZATION\n  private async transcribeChunksWithSpeakers(meetingId: string, language: string): Promise<{\n    transcription: string;\n    speakers: Array<{ id: string; duration: number; percentage: number; }>;\n  }> {\n    console.log(`üîÑ Starting sequential chunk transcription with speaker analysis for meeting ${meetingId}`);\n    \n    const tempDir = path.join('/tmp', 'audio-chunks');\n    let fullTranscription = '';\n    let allSpeakers = new Map<string, { duration: number; segments: number; }>();\n    let totalDuration = 0;\n    let processedChunks = 0;\n    \n    try {\n      // Get all chunk files for this meeting, sorted by index\n      const files = await readdir(tempDir);\n      const chunkFiles = files\n        .filter(file => file.startsWith(`${meetingId}-chunk-`) && file.endsWith('.webm'))\n        .map(file => {\n          const match = file.match(new RegExp(`^${meetingId}-chunk-(\\\\d+)\\\\.webm$`));\n          return match ? { \n            file, \n            chunkIndex: parseInt(match[1]),\n            filePath: path.join(tempDir, file)\n          } : null;\n        })\n        .filter(Boolean)\n        .sort((a, b) => a!.chunkIndex - b!.chunkIndex);\n\n      console.log(`üìã Found ${chunkFiles.length} chunks to process sequentially`);\n      \n      if (chunkFiles.length === 0) {\n        throw new Error('No audio chunks found for transcription');\n      }\n      \n      // Process each chunk individually with per-chunk consent checks\n      for (const chunkFile of chunkFiles) {\n        if (chunkFile && fs.existsSync(chunkFile.filePath)) {\n          try {\n            // GDPR: Check consent before processing each chunk for immediate halt\n            const consentCheck = await storage.getMeeting(meetingId);\n            if (consentCheck?.status === 'cancelled') {\n              console.log(`‚ùå GDPR: Transcription halted at chunk ${chunkFile.chunkIndex} - meeting cancelled`);\n              // Force cleanup of remaining chunks when halted\n              await this.forceCleanupMeetingChunks(meetingId);\n              throw new Error('Processing halted due to meeting cancellation');\n            }\n            \n            console.log(`üéôÔ∏è Processing chunk ${chunkFile.chunkIndex} (${processedChunks + 1}/${chunkFiles.length})...`);\n            \n            // Read chunk into memory temporarily\n            const chunkBuffer = await readFile(chunkFile.filePath);\n            console.log(`üì• Chunk ${chunkFile.chunkIndex} size: ${Math.round(chunkBuffer.length / 1024)} KB`);\n            \n            // Transcribe this chunk WITH speaker analysis  \n            const chunkResult = await transcribeWithSpeakerAnalysis(chunkBuffer, language);\n            \n            // Add to full transcription with space separator\n            if (chunkResult.text.trim()) {\n              fullTranscription += (fullTranscription ? ' ' : '') + chunkResult.text.trim();\n              console.log(`‚úÖ Chunk ${chunkFile.chunkIndex} transcribed: ${chunkResult.text.length} chars, ${chunkResult.speakers.length} speakers`);\n              \n              // Accumulate speaker data\n              totalDuration += chunkResult.totalDuration;\n              for (const speaker of chunkResult.speakers) {\n                if (!allSpeakers.has(speaker.id)) {\n                  allSpeakers.set(speaker.id, { duration: 0, segments: 0 });\n                }\n                const existing = allSpeakers.get(speaker.id)!;\n                existing.duration += speaker.duration;\n                existing.segments++;\n              }\n            }\n            \n            processedChunks++;\n            \n            // Clean up chunk file immediately to save disk space\n            await unlink(chunkFile.filePath);\n            console.log(`üóëÔ∏è Cleaned up chunk file: ${chunkFile.file}`);\n            \n          } catch (error) {\n            console.error(`‚ùå Error processing chunk ${chunkFile.chunkIndex}:`, error);\n            // Continue with next chunk instead of failing completely\n          }\n        }\n      }\n      \n      // Calculate final speaker percentages\n      const speakers = Array.from(allSpeakers.entries()).map(([id, data]) => ({\n        id,\n        duration: Math.round(data.duration * 10) / 10,\n        percentage: totalDuration > 0 ? Math.round((data.duration / totalDuration) * 100) : 0\n      })).sort((a, b) => b.percentage - a.percentage); // Sort by speaking time\n      \n      console.log(`üéâ Sequential transcription completed: ${processedChunks} chunks processed, ${fullTranscription.length} total characters`);\n      console.log(`üë• Final speaker analysis: ${speakers.length} unique speakers over ${Math.round(totalDuration)}s`);\n      speakers.forEach(speaker => {\n        console.log(`   - ${speaker.id}: ${speaker.duration}s (${speaker.percentage}%)`);\n      });\n      \n      return { transcription: fullTranscription, speakers };\n      \n    } catch (error) {\n      console.error(`‚ùå Error in sequential chunk transcription:`, error);\n      \n      // Cleanup remaining chunks on error\n      await this.forceCleanupMeetingChunks(meetingId);\n      throw error;\n    }\n  }\n  \n  // Robust cleanup that doesn't depend on in-memory Map (works after restarts)\n  private async forceCleanupMeetingChunks(meetingId: string): Promise<void> {\n    const tempDir = path.join('/tmp', 'audio-chunks');\n    \n    try {\n      console.log(`üóëÔ∏è Force cleanup: scanning ${tempDir} for meeting ${meetingId} files...`);\n      \n      // Check if temp directory exists\n      if (!fs.existsSync(tempDir)) {\n        console.log(`üóã Temp directory ${tempDir} doesn't exist, nothing to clean`);\n        return;\n      }\n      \n      const files = await readdir(tempDir);\n      const meetingFiles = files.filter(file => file.startsWith(`${meetingId}-chunk-`) && file.endsWith('.webm'));\n      \n      console.log(`üóã Found ${meetingFiles.length} files to cleanup for meeting ${meetingId}`);\n      \n      for (const file of meetingFiles) {\n        const filePath = path.join(tempDir, file);\n        try {\n          if (fs.existsSync(filePath)) {\n            await unlink(filePath);\n            console.log(`‚úÖ Cleaned up: ${file}`);\n          }\n        } catch (error) {\n          console.error(`‚ö†Ô∏è Could not delete ${file}:`, error);\n        }\n      }\n      \n      console.log(`üéâ Cleanup completed for meeting ${meetingId}`);\n      \n    } catch (error) {\n      console.error(`‚ùå Error during force cleanup for meeting ${meetingId}:`, error);\n    }\n  }\n  \n  // AUTO-CLEANUP POLICY: Remove old meetings according to retention settings\n  async runAutoCleanup(): Promise<void> {\n    try {\n      console.log('üîÑ Running auto-cleanup policy for old meetings...');\n      \n      // Get all meetings that could be candidates for cleanup\n      const meetings = await storage.getMeetingsForCleanup();\n      let cleanedCount = 0;\n      \n      for (const meeting of meetings) {\n        if (!meeting.autoCleanupEnabled) {\n          continue;\n        }\n        \n        const retentionDays = meeting.retentionDays || 30;\n        const cutoffDate = new Date();\n        cutoffDate.setDate(cutoffDate.getDate() - retentionDays);\n        \n        // Check if meeting is older than retention period\n        if (meeting.createdAt <= cutoffDate) {\n          console.log(`üóëÔ∏è Auto-cleanup: Meeting \"${meeting.title}\" (${meeting.id}) is ${retentionDays}+ days old`);\n          \n          try {\n            // Clean up associated audio files first\n            await this.forceCleanupMeetingChunks(meeting.id);\n            \n            // Delete meeting from database (cascades to attendees, speakers, chunks)\n            await storage.cleanupMeeting(meeting.id);\n            \n            cleanedCount++;\n            console.log(`‚úÖ Auto-cleanup: Removed meeting \"${meeting.title}\" and all associated data`);\n            \n          } catch (error) {\n            console.error(`‚ùå Auto-cleanup failed for meeting ${meeting.id}:`, error);\n            // Update last cleanup attempt even if failed\n            await storage.updateLastCleanup(meeting.id);\n          }\n        } else {\n          // Meeting is still within retention period, just update last check\n          await storage.updateLastCleanup(meeting.id);\n        }\n      }\n      \n      console.log(`üéâ Auto-cleanup completed: ${cleanedCount} meetings removed`);\n      \n    } catch (error) {\n      console.error('‚ùå Error during auto-cleanup policy execution:', error);\n    }\n  }\n  \n  // Manual cleanup for specific meeting (for user-triggered deletion)\n  async manualCleanupMeeting(meetingId: string): Promise<void> {\n    try {\n      console.log(`üóëÔ∏è Manual cleanup requested for meeting ${meetingId}`);\n      \n      // Clean audio files\n      await this.forceCleanupMeetingChunks(meetingId);\n      \n      // Delete from database\n      await storage.cleanupMeeting(meetingId);\n      \n      console.log(`‚úÖ Manual cleanup completed for meeting ${meetingId}`);\n      \n    } catch (error) {\n      console.error(`‚ùå Manual cleanup failed for meeting ${meetingId}:`, error);\n      throw error;\n    }\n  }\n  \n  // Configure retention policy for a meeting\n  async updateRetentionPolicy(meetingId: string, retentionDays: number, autoCleanup: boolean = true): Promise<void> {\n    await storage.updateMeeting(meetingId, {\n      retentionDays: retentionDays,\n      autoCleanupEnabled: autoCleanup\n    });\n    \n    console.log(`üìù Updated retention policy for meeting ${meetingId}: ${retentionDays} days, auto-cleanup: ${autoCleanup}`);\n  }\n  \n  // Get cleanup statistics\n  async getCleanupStats(): Promise<{\n    totalMeetings: number;\n    meetingsWithAutoCleanup: number;\n    meetingsEligibleForCleanup: number;\n    averageRetentionDays: number;\n  }> {\n    const meetings = await storage.getMeetingsForCleanup();\n    const withAutoCleanup = meetings.filter(m => m.autoCleanupEnabled);\n    \n    let eligibleCount = 0;\n    let totalRetentionDays = 0;\n    \n    for (const meeting of meetings) {\n      const retentionDays = meeting.retentionDays || 30;\n      totalRetentionDays += retentionDays;\n      \n      if (meeting.autoCleanupEnabled) {\n        const cutoffDate = new Date();\n        cutoffDate.setDate(cutoffDate.getDate() - retentionDays);\n        \n        if (meeting.createdAt <= cutoffDate) {\n          eligibleCount++;\n        }\n      }\n    }\n    \n    return {\n      totalMeetings: meetings.length,\n      meetingsWithAutoCleanup: withAutoCleanup.length,\n      meetingsEligibleForCleanup: eligibleCount,\n      averageRetentionDays: meetings.length > 0 ? Math.round(totalRetentionDays / meetings.length) : 30\n    };\n  }\n  \n  // Periodic cleanup of orphaned files (called periodically)\n  async cleanupOrphanedChunks(maxAgeHours: number = 24): Promise<void> {\n    const tempDir = path.join('/tmp', 'audio-chunks');\n    \n    try {\n      console.log(`üîÑ Running periodic cleanup of orphaned chunks older than ${maxAgeHours} hours...`);\n      \n      if (!fs.existsSync(tempDir)) {\n        console.log(`üóã No temp directory found at ${tempDir}`);\n        return;\n      }\n      \n      const files = await readdir(tempDir);\n      const chunkFiles = files.filter(file => file.match(/^[a-f0-9-]+-chunk-\\d+\\.webm$/));\n      \n      let cleanedCount = 0;\n      const maxAge = maxAgeHours * 60 * 60 * 1000; // Convert to milliseconds\n      \n      for (const file of chunkFiles) {\n        const filePath = path.join(tempDir, file);\n        try {\n          const stats = fs.statSync(filePath);\n          const age = Date.now() - stats.mtime.getTime();\n          \n          if (age > maxAge) {\n            await unlink(filePath);\n            console.log(`üóëÔ∏è Cleaned up orphaned chunk: ${file} (${Math.round(age / 1000 / 60)} minutes old)`);\n            cleanedCount++;\n          }\n        } catch (error) {\n          console.error(`‚ö†Ô∏è Error checking/deleting orphaned file ${file}:`, error);\n        }\n      }\n      \n      console.log(`üéâ Periodic cleanup completed: ${cleanedCount} orphaned files removed`);\n      \n    } catch (error) {\n      console.error(`‚ùå Error during periodic cleanup:`, error);\n    }\n  }\n\n  // Send email summary to attendees (with speaker info if available)\n  private async sendEmailSummary(\n    meeting: any, \n    transcription: string, \n    summary: MeetingSummary\n  ): Promise<void> {\n    try {\n      console.log(`sendEmailSummary called for meeting ${meeting.id} with ${meeting.attendees.length} attendees`);\n      console.log('Attendees:', meeting.attendees.map((a: any) => a.email));\n      \n      const { emailService } = await import('./emailService');\n      \n      console.log('EmailService imported, calling sendMeetingSummary...');\n      \n      // Enhance summary with speaker information if available\n      const enhancedSummary = {\n        ...summary,\n        speakers: meeting.speakers || []\n      };\n      \n      const success = await emailService.sendMeetingSummary(\n        meeting.title,\n        meeting.attendees,\n        transcription,\n        enhancedSummary,\n        meeting.language || 'nl',\n        meeting // Pass full meeting object with consent info\n      );\n\n      if (success) {\n        console.log(`‚úÖ Email summary sent successfully for meeting ${meeting.id}`);\n      } else {\n        console.error(`‚ùå Failed to send email summary for meeting ${meeting.id}`);\n      }\n    } catch (error: any) {\n      console.error(`‚ùå Error sending email summary for meeting ${meeting.id}:`, error);\n      console.error('Error details:', error?.message || error);\n    }\n  }\n}\n\nexport const processingService = new MeetingProcessingService();"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AAEA;AACA;AACA;;;;;;;AAEA,MAAM,UAAU,IAAA,8GAAS,EAAC,wGAAU;AACpC,MAAM,WAAW,IAAA,8GAAS,EAAC,yGAAW;AACtC,MAAM,SAAS,IAAA,8GAAS,EAAC,uGAAS;AAE3B,MAAM;IACH,kBAA8C,IAAI,MAAM;IACxD,kBAAiC,QAAQ,OAAO,GAAG;IACnD,gBAAiC;IAEzC,aAAc;QACZ,yEAAyE;QACzE,0CAA0C;QAC1C,IAAI,CAAC,eAAe,GAAG,YAAY;YACjC,8BAA8B;YAC9B,IAAI,CAAC,qBAAqB,CAAC,IAAI,KAAK,CAAC,CAAA,MACnC,QAAQ,KAAK,CAAC,4CAA4C;YAG5D,mDAAmD;YACnD,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC,CAAA,MAC1B,QAAQ,KAAK,CAAC,oCAAoC;QAEtD,GAAG,IAAI,KAAK,KAAK,OAAO,UAAU;IACpC;IAEA,2FAA2F;IAC3F,MAAM,eAAe,SAAiB,EAAiB;QACrD,2CAA2C;QAC3C,IAAI,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,YAAY;YACvC,QAAQ,GAAG,CAAC,CAAC,WAAW,EAAE,UAAU,2BAA2B,CAAC;YAChE,OAAO,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC;QAClC;QAEA,0EAA0E;QAC1E,MAAM,oBAAoB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC;YAClD,QAAQ,GAAG,CAAC,CAAC,8CAA8C,EAAE,WAAW;YACxE,OAAO,IAAI,CAAC,gBAAgB,CAAC;QAC/B,GAAG,OAAO,CAAC;YACT,gCAAgC;YAChC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC;YAC5B,QAAQ,GAAG,CAAC,CAAC,sCAAsC,EAAE,WAAW;QAClE;QAEA,gCAAgC;QAChC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,WAAW;QACpC,IAAI,CAAC,eAAe,GAAG,kBAAkB,KAAK,CAAC,KAAO,IAAI,gCAAgC;QAE1F,OAAO;IACT;IAEA,6BAA6B;IAC7B,MAAc,iBAAiB,SAAiB,EAAiB;QAC/D,IAAI;YACF,QAAQ,GAAG,CAAC,CAAC,gCAAgC,EAAE,WAAW;YAE1D,sBAAsB;YACtB,MAAM,UAAU,MAAM,8HAAO,CAAC,uBAAuB,CAAC;YACtD,IAAI,CAAC,SAAS;gBACZ,MAAM,IAAI,MAAM,CAAC,QAAQ,EAAE,UAAU,UAAU,CAAC;YAClD;YAEA,4FAA4F;YAC5F,IAAI,CAAC,QAAQ,qBAAqB,IAAI,QAAQ,MAAM,KAAK,aAAa;gBACpE,QAAQ,GAAG,CAAC,CAAC,+BAA+B,EAAE,UAAU,gDAAgD,CAAC;gBACzG,MAAM,8HAAO,CAAC,aAAa,CAAC,WAAW;oBACrC,QAAQ;oBACR,SAAS;wBAAE,OAAO;oBAA0D;gBAC9E;gBACA;YACF;YAEA,8BAA8B;YAC9B,MAAM,8HAAO,CAAC,aAAa,CAAC,WAAW;gBAAE,QAAQ;YAAa;YAE9D,wDAAwD;YACxD,MAAM,gBAAgB,MAAM,8HAAO,CAAC,UAAU,CAAC;YAC/C,IAAI,eAAe,WAAW,aAAa;gBACzC,QAAQ,GAAG,CAAC,CAAC,wEAAwE,CAAC;gBACtF;YACF;YAEA,4EAA4E;YAC5E,QAAQ,GAAG,CAAC;YACZ,MAAM,EAAE,aAAa,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAI,CAAC,4BAA4B,CAAC,WAAW,QAAQ,QAAQ,IAAI;YAC3G,IAAI,CAAC,iBAAiB,cAAc,MAAM,KAAK,GAAG;gBAChD,MAAM,IAAI,MAAM;YAClB;YAEA,QAAQ,GAAG,CAAC,CAAC,sCAAsC,EAAE,cAAc,MAAM,CAAC,SAAS,EAAE,cAAc,SAAS,CAAC,GAAG,KAAK,GAAG,CAAC;YACzH,QAAQ,GAAG,CAAC,CAAC,qBAAqB,EAAE,SAAS,MAAM,CAAC,kBAAkB,CAAC;YAEvE,gCAAgC;YAChC,IAAI,SAAS,MAAM,GAAG,GAAG;gBACvB,MAAM,8HAAO,CAAC,WAAW,CAAC,WAAW,SAAS,GAAG,CAAC,CAAA,UAAW,CAAC;wBAC5D,WAAW,QAAQ,EAAE;wBACrB,UAAU,KAAK,KAAK,CAAC,QAAQ,QAAQ;wBACrC,YAAY,QAAQ,UAAU;oBAChC,CAAC;gBAED,uCAAuC;gBACvC,MAAM,8HAAO,CAAC,aAAa,CAAC,WAAW;oBAAE,aAAa;gBAAgB;gBACtE,QAAQ,GAAG,CAAC,CAAC,SAAS,EAAE,SAAS,MAAM,CAAC,qBAAqB,CAAC;YAChE;YAEA,sDAAsD;YACtD,MAAM,gBAAgB,MAAM,8HAAO,CAAC,UAAU,CAAC;YAC/C,IAAI,eAAe,WAAW,aAAa;gBACzC,QAAQ,GAAG,CAAC,CAAC,qEAAqE,CAAC;gBACnF;YACF;YAEA,mBAAmB;YACnB,QAAQ,GAAG,CAAC;YACZ,MAAM,UAAU,MAAM,IAAA,4IAAsB,EAC1C,eACA,QAAQ,KAAK,EACb,QAAQ,QAAQ,IAAI;YAGtB,8BAA8B;YAC9B,MAAM,8HAAO,CAAC,aAAa,CAAC,WAAW;gBACrC,QAAQ;gBACR,eAAe;gBACf,SAAS;YACX;YAEA,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,UAAU,kCAAkC,CAAC;YAEpE,6CAA6C;YAC7C,MAAM,IAAI,CAAC,yBAAyB,CAAC;YAErC,kDAAkD;YAClD,MAAM,gBAAgB,MAAM,8HAAO,CAAC,UAAU,CAAC;YAC/C,IAAI,eAAe,WAAW,aAAa;gBACzC,QAAQ,GAAG,CAAC,CAAC,iDAAiD,CAAC;gBAC/D;YACF;YAEA,kEAAkE;YAClE,QAAQ,GAAG,CAAC,CAAC,oCAAoC,EAAE,UAAU,IAAI,EAAE,QAAQ,SAAS,CAAC,MAAM,CAAC,UAAU,CAAC;YACvG,MAAM,sBAAsB,MAAM,8HAAO,CAAC,uBAAuB,CAAC;YAClE,MAAM,IAAI,CAAC,gBAAgB,CAAC,uBAAuB,SAAS,eAAe;QAE7E,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,CAAC,yBAAyB,EAAE,UAAU,CAAC,CAAC,EAAE;YAExD,iBAAiB;YACjB,MAAM,8HAAO,CAAC,aAAa,CAAC,WAAW;gBACrC,QAAQ;gBACR,SAAS;oBAAE,OAAO,MAAM,OAAO;gBAAC;YAClC;YAEA,MAAM;QACR;IACF;IAEA,yEAAyE;IACzE,MAAc,6BAA6B,SAAiB,EAAE,QAAgB,EAG3E;QACD,QAAQ,GAAG,CAAC,CAAC,6EAA6E,EAAE,WAAW;QAEvG,MAAM,UAAU,yGAAS,CAAC,QAAQ;QAClC,IAAI,oBAAoB;QACxB,IAAI,cAAc,IAAI;QACtB,IAAI,gBAAgB;QACpB,IAAI,kBAAkB;QAEtB,IAAI;YACF,wDAAwD;YACxD,MAAM,QAAQ,MAAM,QAAQ;YAC5B,MAAM,aAAa,MAChB,MAAM,CAAC,CAAA,OAAQ,KAAK,UAAU,CAAC,GAAG,UAAU,OAAO,CAAC,KAAK,KAAK,QAAQ,CAAC,UACvE,GAAG,CAAC,CAAA;gBACH,MAAM,QAAQ,KAAK,KAAK,CAAC,IAAI,OAAO,CAAC,CAAC,EAAE,UAAU,qBAAqB,CAAC;gBACxE,OAAO,QAAQ;oBACb;oBACA,YAAY,SAAS,KAAK,CAAC,EAAE;oBAC7B,UAAU,yGAAS,CAAC,SAAS;gBAC/B,IAAI;YACN,GACC,MAAM,CAAC,SACP,IAAI,CAAC,CAAC,GAAG,IAAM,EAAG,UAAU,GAAG,EAAG,UAAU;YAE/C,QAAQ,GAAG,CAAC,CAAC,SAAS,EAAE,WAAW,MAAM,CAAC,+BAA+B,CAAC;YAE1E,IAAI,WAAW,MAAM,KAAK,GAAG;gBAC3B,MAAM,IAAI,MAAM;YAClB;YAEA,gEAAgE;YAChE,KAAK,MAAM,aAAa,WAAY;gBAClC,IAAI,aAAa,2GAAa,CAAC,UAAU,QAAQ,GAAG;oBAClD,IAAI;wBACF,sEAAsE;wBACtE,MAAM,eAAe,MAAM,8HAAO,CAAC,UAAU,CAAC;wBAC9C,IAAI,cAAc,WAAW,aAAa;4BACxC,QAAQ,GAAG,CAAC,CAAC,sCAAsC,EAAE,UAAU,UAAU,CAAC,oBAAoB,CAAC;4BAC/F,gDAAgD;4BAChD,MAAM,IAAI,CAAC,yBAAyB,CAAC;4BACrC,MAAM,IAAI,MAAM;wBAClB;wBAEA,QAAQ,GAAG,CAAC,CAAC,qBAAqB,EAAE,UAAU,UAAU,CAAC,EAAE,EAAE,kBAAkB,EAAE,CAAC,EAAE,WAAW,MAAM,CAAC,IAAI,CAAC;wBAE3G,qCAAqC;wBACrC,MAAM,cAAc,MAAM,SAAS,UAAU,QAAQ;wBACrD,QAAQ,GAAG,CAAC,CAAC,SAAS,EAAE,UAAU,UAAU,CAAC,OAAO,EAAE,KAAK,KAAK,CAAC,YAAY,MAAM,GAAG,MAAM,GAAG,CAAC;wBAEhG,gDAAgD;wBAChD,MAAM,cAAc,MAAM,IAAA,uJAA6B,EAAC,aAAa;wBAErE,iDAAiD;wBACjD,IAAI,YAAY,IAAI,CAAC,IAAI,IAAI;4BAC3B,qBAAqB,CAAC,oBAAoB,MAAM,EAAE,IAAI,YAAY,IAAI,CAAC,IAAI;4BAC3E,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,UAAU,UAAU,CAAC,cAAc,EAAE,YAAY,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,YAAY,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC;4BAEpI,0BAA0B;4BAC1B,iBAAiB,YAAY,aAAa;4BAC1C,KAAK,MAAM,WAAW,YAAY,QAAQ,CAAE;gCAC1C,IAAI,CAAC,YAAY,GAAG,CAAC,QAAQ,EAAE,GAAG;oCAChC,YAAY,GAAG,CAAC,QAAQ,EAAE,EAAE;wCAAE,UAAU;wCAAG,UAAU;oCAAE;gCACzD;gCACA,MAAM,WAAW,YAAY,GAAG,CAAC,QAAQ,EAAE;gCAC3C,SAAS,QAAQ,IAAI,QAAQ,QAAQ;gCACrC,SAAS,QAAQ;4BACnB;wBACF;wBAEA;wBAEA,qDAAqD;wBACrD,MAAM,OAAO,UAAU,QAAQ;wBAC/B,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,UAAU,IAAI,EAAE;oBAE5D,EAAE,OAAO,OAAO;wBACd,QAAQ,KAAK,CAAC,CAAC,yBAAyB,EAAE,UAAU,UAAU,CAAC,CAAC,CAAC,EAAE;oBACnE,yDAAyD;oBAC3D;gBACF;YACF;YAEA,sCAAsC;YACtC,MAAM,WAAW,MAAM,IAAI,CAAC,YAAY,OAAO,IAAI,GAAG,CAAC,CAAC,CAAC,IAAI,KAAK,GAAK,CAAC;oBACtE;oBACA,UAAU,KAAK,KAAK,CAAC,KAAK,QAAQ,GAAG,MAAM;oBAC3C,YAAY,gBAAgB,IAAI,KAAK,KAAK,CAAC,AAAC,KAAK,QAAQ,GAAG,gBAAiB,OAAO;gBACtF,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,UAAU,GAAG,EAAE,UAAU,GAAG,wBAAwB;YAEzE,QAAQ,GAAG,CAAC,CAAC,uCAAuC,EAAE,gBAAgB,mBAAmB,EAAE,kBAAkB,MAAM,CAAC,iBAAiB,CAAC;YACtI,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,SAAS,MAAM,CAAC,sBAAsB,EAAE,KAAK,KAAK,CAAC,eAAe,CAAC,CAAC;YAC9G,SAAS,OAAO,CAAC,CAAA;gBACf,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAC,EAAE,EAAE,QAAQ,QAAQ,CAAC,GAAG,EAAE,QAAQ,UAAU,CAAC,EAAE,CAAC;YACjF;YAEA,OAAO;gBAAE,eAAe;gBAAmB;YAAS;QAEtD,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,0CAA0C,CAAC,EAAE;YAE5D,oCAAoC;YACpC,MAAM,IAAI,CAAC,yBAAyB,CAAC;YACrC,MAAM;QACR;IACF;IAEA,6EAA6E;IAC7E,MAAc,0BAA0B,SAAiB,EAAiB;QACxE,MAAM,UAAU,yGAAS,CAAC,QAAQ;QAElC,IAAI;YACF,QAAQ,GAAG,CAAC,CAAC,4BAA4B,EAAE,QAAQ,aAAa,EAAE,UAAU,SAAS,CAAC;YAEtF,iCAAiC;YACjC,IAAI,CAAC,2GAAa,CAAC,UAAU;gBAC3B,QAAQ,GAAG,CAAC,CAAC,kBAAkB,EAAE,QAAQ,gCAAgC,CAAC;gBAC1E;YACF;YAEA,MAAM,QAAQ,MAAM,QAAQ;YAC5B,MAAM,eAAe,MAAM,MAAM,CAAC,CAAA,OAAQ,KAAK,UAAU,CAAC,GAAG,UAAU,OAAO,CAAC,KAAK,KAAK,QAAQ,CAAC;YAElG,QAAQ,GAAG,CAAC,CAAC,SAAS,EAAE,aAAa,MAAM,CAAC,8BAA8B,EAAE,WAAW;YAEvF,KAAK,MAAM,QAAQ,aAAc;gBAC/B,MAAM,WAAW,yGAAS,CAAC,SAAS;gBACpC,IAAI;oBACF,IAAI,2GAAa,CAAC,WAAW;wBAC3B,MAAM,OAAO;wBACb,QAAQ,GAAG,CAAC,CAAC,cAAc,EAAE,MAAM;oBACrC;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,CAAC,oBAAoB,EAAE,KAAK,CAAC,CAAC,EAAE;gBAChD;YACF;YAEA,QAAQ,GAAG,CAAC,CAAC,iCAAiC,EAAE,WAAW;QAE7D,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,yCAAyC,EAAE,UAAU,CAAC,CAAC,EAAE;QAC1E;IACF;IAEA,2EAA2E;IAC3E,MAAM,iBAAgC;QACpC,IAAI;YACF,QAAQ,GAAG,CAAC;YAEZ,wDAAwD;YACxD,MAAM,WAAW,MAAM,8HAAO,CAAC,qBAAqB;YACpD,IAAI,eAAe;YAEnB,KAAK,MAAM,WAAW,SAAU;gBAC9B,IAAI,CAAC,QAAQ,kBAAkB,EAAE;oBAC/B;gBACF;gBAEA,MAAM,gBAAgB,QAAQ,aAAa,IAAI;gBAC/C,MAAM,aAAa,IAAI;gBACvB,WAAW,OAAO,CAAC,WAAW,OAAO,KAAK;gBAE1C,kDAAkD;gBAClD,IAAI,QAAQ,SAAS,IAAI,YAAY;oBACnC,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,QAAQ,KAAK,CAAC,GAAG,EAAE,QAAQ,EAAE,CAAC,KAAK,EAAE,cAAc,UAAU,CAAC;oBAExG,IAAI;wBACF,wCAAwC;wBACxC,MAAM,IAAI,CAAC,yBAAyB,CAAC,QAAQ,EAAE;wBAE/C,yEAAyE;wBACzE,MAAM,8HAAO,CAAC,cAAc,CAAC,QAAQ,EAAE;wBAEvC;wBACA,QAAQ,GAAG,CAAC,CAAC,iCAAiC,EAAE,QAAQ,KAAK,CAAC,yBAAyB,CAAC;oBAE1F,EAAE,OAAO,OAAO;wBACd,QAAQ,KAAK,CAAC,CAAC,kCAAkC,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE;wBAClE,6CAA6C;wBAC7C,MAAM,8HAAO,CAAC,iBAAiB,CAAC,QAAQ,EAAE;oBAC5C;gBACF,OAAO;oBACL,mEAAmE;oBACnE,MAAM,8HAAO,CAAC,iBAAiB,CAAC,QAAQ,EAAE;gBAC5C;YACF;YAEA,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,aAAa,iBAAiB,CAAC;QAE3E,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,iDAAiD;QACjE;IACF;IAEA,oEAAoE;IACpE,MAAM,qBAAqB,SAAiB,EAAiB;QAC3D,IAAI;YACF,QAAQ,GAAG,CAAC,CAAC,yCAAyC,EAAE,WAAW;YAEnE,oBAAoB;YACpB,MAAM,IAAI,CAAC,yBAAyB,CAAC;YAErC,uBAAuB;YACvB,MAAM,8HAAO,CAAC,cAAc,CAAC;YAE7B,QAAQ,GAAG,CAAC,CAAC,uCAAuC,EAAE,WAAW;QAEnE,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,oCAAoC,EAAE,UAAU,CAAC,CAAC,EAAE;YACnE,MAAM;QACR;IACF;IAEA,2CAA2C;IAC3C,MAAM,sBAAsB,SAAiB,EAAE,aAAqB,EAAE,cAAuB,IAAI,EAAiB;QAChH,MAAM,8HAAO,CAAC,aAAa,CAAC,WAAW;YACrC,eAAe;YACf,oBAAoB;QACtB;QAEA,QAAQ,GAAG,CAAC,CAAC,wCAAwC,EAAE,UAAU,EAAE,EAAE,cAAc,qBAAqB,EAAE,aAAa;IACzH;IAEA,yBAAyB;IACzB,MAAM,kBAKH;QACD,MAAM,WAAW,MAAM,8HAAO,CAAC,qBAAqB;QACpD,MAAM,kBAAkB,SAAS,MAAM,CAAC,CAAA,IAAK,EAAE,kBAAkB;QAEjE,IAAI,gBAAgB;QACpB,IAAI,qBAAqB;QAEzB,KAAK,MAAM,WAAW,SAAU;YAC9B,MAAM,gBAAgB,QAAQ,aAAa,IAAI;YAC/C,sBAAsB;YAEtB,IAAI,QAAQ,kBAAkB,EAAE;gBAC9B,MAAM,aAAa,IAAI;gBACvB,WAAW,OAAO,CAAC,WAAW,OAAO,KAAK;gBAE1C,IAAI,QAAQ,SAAS,IAAI,YAAY;oBACnC;gBACF;YACF;QACF;QAEA,OAAO;YACL,eAAe,SAAS,MAAM;YAC9B,yBAAyB,gBAAgB,MAAM;YAC/C,4BAA4B;YAC5B,sBAAsB,SAAS,MAAM,GAAG,IAAI,KAAK,KAAK,CAAC,qBAAqB,SAAS,MAAM,IAAI;QACjG;IACF;IAEA,2DAA2D;IAC3D,MAAM,sBAAsB,cAAsB,EAAE,EAAiB;QACnE,MAAM,UAAU,yGAAS,CAAC,QAAQ;QAElC,IAAI;YACF,QAAQ,GAAG,CAAC,CAAC,0DAA0D,EAAE,YAAY,SAAS,CAAC;YAE/F,IAAI,CAAC,2GAAa,CAAC,UAAU;gBAC3B,QAAQ,GAAG,CAAC,CAAC,8BAA8B,EAAE,SAAS;gBACtD;YACF;YAEA,MAAM,QAAQ,MAAM,QAAQ;YAC5B,MAAM,aAAa,MAAM,MAAM,CAAC,CAAA,OAAQ,KAAK,KAAK,CAAC;YAEnD,IAAI,eAAe;YACnB,MAAM,SAAS,cAAc,KAAK,KAAK,MAAM,0BAA0B;YAEvE,KAAK,MAAM,QAAQ,WAAY;gBAC7B,MAAM,WAAW,yGAAS,CAAC,SAAS;gBACpC,IAAI;oBACF,MAAM,QAAQ,yGAAW,CAAC;oBAC1B,MAAM,MAAM,KAAK,GAAG,KAAK,MAAM,KAAK,CAAC,OAAO;oBAE5C,IAAI,MAAM,QAAQ;wBAChB,MAAM,OAAO;wBACb,QAAQ,GAAG,CAAC,CAAC,+BAA+B,EAAE,KAAK,EAAE,EAAE,KAAK,KAAK,CAAC,MAAM,OAAO,IAAI,aAAa,CAAC;wBACjG;oBACF;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,CAAC,yCAAyC,EAAE,KAAK,CAAC,CAAC,EAAE;gBACrE;YACF;YAEA,QAAQ,GAAG,CAAC,CAAC,+BAA+B,EAAE,aAAa,uBAAuB,CAAC;QAErF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,gCAAgC,CAAC,EAAE;QACpD;IACF;IAEA,mEAAmE;IACnE,MAAc,iBACZ,OAAY,EACZ,aAAqB,EACrB,OAAuB,EACR;QACf,IAAI;YACF,QAAQ,GAAG,CAAC,CAAC,oCAAoC,EAAE,QAAQ,EAAE,CAAC,MAAM,EAAE,QAAQ,SAAS,CAAC,MAAM,CAAC,UAAU,CAAC;YAC1G,QAAQ,GAAG,CAAC,cAAc,QAAQ,SAAS,CAAC,GAAG,CAAC,CAAC,IAAW,EAAE,KAAK;YAEnE,MAAM,EAAE,YAAY,EAAE,GAAG;YAEzB,QAAQ,GAAG,CAAC;YAEZ,wDAAwD;YACxD,MAAM,kBAAkB;gBACtB,GAAG,OAAO;gBACV,UAAU,QAAQ,QAAQ,IAAI,EAAE;YAClC;YAEA,MAAM,UAAU,MAAM,aAAa,kBAAkB,CACnD,QAAQ,KAAK,EACb,QAAQ,SAAS,EACjB,eACA,iBACA,QAAQ,QAAQ,IAAI,MACpB,QAAQ,6CAA6C;;YAGvD,IAAI,SAAS;gBACX,QAAQ,GAAG,CAAC,CAAC,8CAA8C,EAAE,QAAQ,EAAE,EAAE;YAC3E,OAAO;gBACL,QAAQ,KAAK,CAAC,CAAC,2CAA2C,EAAE,QAAQ,EAAE,EAAE;YAC1E;QACF,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,CAAC,0CAA0C,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE;YAC1E,QAAQ,KAAK,CAAC,kBAAkB,OAAO,WAAW;QACpD;IACF;AACF;AAEO,MAAM,oBAAoB,IAAI","debugId":null}}]
}