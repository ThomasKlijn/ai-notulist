{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/shared/schema.ts"],"sourcesContent":["import { pgTable, varchar, text, timestamp, integer, jsonb, serial, boolean, index } from 'drizzle-orm/pg-core';\nimport { sql } from 'drizzle-orm';\nimport { createInsertSchema } from 'drizzle-zod';\nimport { z } from 'zod';\n\n// Meetings table\nexport const meetings = pgTable('meetings', {\n  id: varchar('id').primaryKey(),\n  title: varchar('title', { length: 255 }).notNull(),\n  language: varchar('language', { length: 10 }).default('nl'),\n  status: varchar('status', { length: 20 }).notNull().default('recording'), // 'recording' | 'processing' | 'completed' | 'failed'\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  finishedAt: timestamp('finished_at'),\n  transcription: text('transcription'),\n  summary: jsonb('summary'), // Will store structured summary with key points, decisions, actions\n  speakerData: jsonb('speaker_data'), // Raw speaker analysis from ElevenLabs\n  retentionDays: integer('retention_days').default(30).notNull(), // Auto-cleanup after X days\n  autoCleanupEnabled: boolean('auto_cleanup_enabled').default(true).notNull(),\n  lastCleanupAt: timestamp('last_cleanup_at'),\n  userId: varchar('user_id').notNull(), // Link meetings to users\n  organizerConsentGiven: boolean('organizer_consent_given').notNull().default(false),\n  organizerConsentTimestamp: timestamp('organizer_consent_timestamp'),\n  allAttendeesConsented: boolean('all_attendees_consented').default(false).notNull(),\n});\n\n// Attendees table\nexport const attendees = pgTable('attendees', {\n  id: serial('id').primaryKey(),\n  meetingId: varchar('meeting_id').notNull().references(() => meetings.id, { onDelete: 'cascade' }),\n  name: varchar('name', { length: 255 }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 100 }),\n  // GDPR Consent tracking per attendee\n  consentGiven: boolean('consent_given').default(false).notNull(),\n  consentTimestamp: timestamp('consent_timestamp'),\n  consentPolicyVersion: varchar('consent_policy_version', { length: 20 }).default('v1.0'),\n  consentWithdrawn: boolean('consent_withdrawn').default(false).notNull(),\n  withdrawalTimestamp: timestamp('withdrawal_timestamp'),\n  consentToken: varchar('consent_token', { length: 64 }), // Unique token for consent links\n});\n\n// Audio chunks table - tracks audio file segments\nexport const audioChunks = pgTable('audio_chunks', {\n  id: serial('id').primaryKey(),\n  meetingId: varchar('meeting_id').notNull().references(() => meetings.id, { onDelete: 'cascade' }),\n  chunkIndex: integer('chunk_index').notNull(),\n  filename: varchar('filename', { length: 255 }).notNull(),\n  objectPath: varchar('object_path', { length: 500 }), // Path in object storage\n  sizeBytes: integer('size_bytes'),\n  uploadedAt: timestamp('uploaded_at').defaultNow().notNull(),\n});\n\n// Speakers table - tracks individual speakers in meetings\nexport const speakers = pgTable('speakers', {\n  id: serial('id').primaryKey(),\n  meetingId: varchar('meeting_id').notNull().references(() => meetings.id, { onDelete: 'cascade' }),\n  speakerId: varchar('speaker_id', { length: 50 }).notNull(), // ElevenLabs speaker identifier\n  speakerName: varchar('speaker_name', { length: 255 }), // Optional human-readable name\n  duration: integer('duration').notNull(), // Speaking time in seconds\n  percentage: integer('percentage').notNull(), // Percentage of total meeting time\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n});\n\n// Relations\nimport { relations } from 'drizzle-orm';\n\nexport const meetingsRelations = relations(meetings, ({ many }) => ({\n  attendees: many(attendees),\n  audioChunks: many(audioChunks),\n  speakers: many(speakers),\n}));\n\nexport const attendeesRelations = relations(attendees, ({ one }) => ({\n  meeting: one(meetings, {\n    fields: [attendees.meetingId],\n    references: [meetings.id],\n  }),\n}));\n\nexport const audioChunksRelations = relations(audioChunks, ({ one }) => ({\n  meeting: one(meetings, {\n    fields: [audioChunks.meetingId],\n    references: [meetings.id],\n  }),\n}));\n\nexport const speakersRelations = relations(speakers, ({ one }) => ({\n  meeting: one(meetings, {\n    fields: [speakers.meetingId],\n    references: [meetings.id],\n  }),\n}));\n\n// Session storage table (required for Replit Auth)\nexport const sessions = pgTable(\n  \"sessions\",\n  {\n    sid: varchar(\"sid\").primaryKey(),\n    sess: jsonb(\"sess\").notNull(),\n    expire: timestamp(\"expire\").notNull(),\n  },\n  (table) => ({\n    expireIdx: index(\"IDX_session_expire\").on(table.expire),\n  }),\n);\n\n// User storage table (required for Replit Auth)\nexport const users = pgTable(\"users\", {\n  id: varchar(\"id\").primaryKey(),\n  email: varchar(\"email\").unique(),\n  firstName: varchar(\"first_name\"),\n  lastName: varchar(\"last_name\"),\n  profileImageUrl: varchar(\"profile_image_url\"),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n});\n\n// User relations  \nexport const usersRelations = relations(users, ({ many }) => ({\n  meetings: many(meetings),\n}));\n\n// Update meetings relation to include user\nexport const meetingsRelationsExtended = relations(meetings, ({ many, one }) => ({\n  attendees: many(attendees),\n  audioChunks: many(audioChunks),\n  speakers: many(speakers),\n  user: one(users, {\n    fields: [meetings.userId],\n    references: [users.id],\n  }),\n}));\n\n// Zod schemas for validation\nexport const insertMeetingSchema = createInsertSchema(meetings).omit({\n  createdAt: true,\n  finishedAt: true,\n  transcription: true,\n  summary: true,\n  speakerData: true,\n  lastCleanupAt: true,\n  userId: true,\n  organizerConsentTimestamp: true,\n  allAttendeesConsented: true,\n});\n\nexport const insertAttendeeSchema = createInsertSchema(attendees).omit({\n  id: true,\n  meetingId: true,\n  consentGiven: true,\n  consentTimestamp: true,\n  consentPolicyVersion: true,\n  consentWithdrawn: true,\n  withdrawalTimestamp: true,\n  consentToken: true,\n});\n\nexport const insertAudioChunkSchema = createInsertSchema(audioChunks).omit({\n  id: true,\n  uploadedAt: true,\n});\n\nexport const insertSpeakerSchema = createInsertSchema(speakers).omit({\n  id: true,\n  meetingId: true,\n  createdAt: true,\n});\n\n// Types\nexport type Meeting = typeof meetings.$inferSelect;\nexport type InsertMeeting = z.infer<typeof insertMeetingSchema>;\nexport type Attendee = typeof attendees.$inferSelect;\nexport type InsertAttendee = z.infer<typeof insertAttendeeSchema>;\nexport type AudioChunk = typeof audioChunks.$inferSelect;\nexport type InsertAudioChunk = z.infer<typeof insertAudioChunkSchema>;\nexport type Speaker = typeof speakers.$inferSelect;\nexport type InsertSpeaker = z.infer<typeof insertSpeakerSchema>;\n\n// Extended types for API responses\nexport type MeetingWithAttendees = Meeting & {\n  attendees: Attendee[];\n  audioChunks?: AudioChunk[];\n  speakers?: Speaker[];\n};\n\n// Speaker analysis data from ElevenLabs\nexport interface SpeakerAnalysis {\n  id: string;\n  duration: number;\n  percentage: number;\n}\n\n// Enhanced meeting summary with speaker information\nexport interface MeetingSummaryWithSpeakers {\n  title: string;\n  generalSummary: string;\n  keyPoints: string[];\n  decisions: string[];\n  actionItems: Array<{\n    task: string;\n    assignee?: string;\n    dueDate?: string;\n  }>;\n  participants: string[];\n  speakers?: SpeakerAnalysis[];\n  duration: string;\n  nextSteps?: string[];\n}\n\n// User types\nexport type User = typeof users.$inferSelect;\nexport type UpsertUser = typeof users.$inferInsert;"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 345, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/server/db.ts"],"sourcesContent":["import { Pool, neonConfig } from '@neondatabase/serverless';\nimport { drizzle } from 'drizzle-orm/neon-serverless';\nimport * as schema from \"../shared/schema\";\n\n// @ts-ignore\nimport ws from \"ws\";\nneonConfig.webSocketConstructor = ws;\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\n    \"DATABASE_URL must be set. Did you forget to provision a database?\",\n  );\n}\n\nexport const pool = new Pool({ connectionString: process.env.DATABASE_URL });\nexport const db = drizzle(pool, { schema });"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AAEA,aAAa;AACb;;;;;AACA,sKAAU,CAAC,oBAAoB,GAAG,2JAAE;AAEpC,IAAI,CAAC,QAAQ,GAAG,CAAC,YAAY,EAAE;IAC7B,MAAM,IAAI,MACR;AAEJ;AAEO,MAAM,OAAO,IAAI,gKAAI,CAAC;IAAE,kBAAkB,QAAQ,GAAG,CAAC,YAAY;AAAC;AACnE,MAAM,KAAK,IAAA,2KAAO,EAAC,MAAM;IAAE,QAAA;AAAO","debugId":null}},
    {"offset": {"line": 374, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/server/storage.ts"],"sourcesContent":["import { db } from \"./db\";\nimport { meetings, attendees, audioChunks, speakers, users, type Meeting, type Attendee, type AudioChunk, type Speaker, type User, type InsertMeeting, type InsertAttendee, type InsertAudioChunk, type InsertSpeaker, type UpsertUser, type MeetingWithAttendees } from \"../shared/schema\";\nimport { eq, and, lt } from \"drizzle-orm\";\n\nexport interface IStorage {\n  // Meeting operations  \n  createMeeting(meeting: InsertMeeting, attendeesList: InsertAttendee[], userId: string): Promise<Meeting>;\n  getMeeting(id: string): Promise<Meeting | undefined>;\n  getMeetingWithAttendees(id: string): Promise<MeetingWithAttendees | undefined>;\n  updateMeeting(id: string, updates: Partial<Meeting>): Promise<void>;\n  finishMeeting(id: string): Promise<void>;\n  \n  // Audio chunk operations\n  addAudioChunk(chunk: InsertAudioChunk): Promise<AudioChunk>;\n  getAudioChunks(meetingId: string): Promise<AudioChunk[]>;\n  incrementChunkCount(meetingId: string): Promise<void>;\n  \n  // Speaker operations\n  addSpeakers(meetingId: string, speakersList: InsertSpeaker[]): Promise<Speaker[]>;\n  getSpeakers(meetingId: string): Promise<Speaker[]>;\n  updateSpeakerName(meetingId: string, speakerId: string, name: string): Promise<void>;\n  \n  // Auto-cleanup operations\n  getMeetingsForCleanup(retentionDays?: number): Promise<Meeting[]>;\n  cleanupMeeting(meetingId: string): Promise<void>;\n  updateLastCleanup(meetingId: string): Promise<void>;\n  \n  // User operations (required for Replit Auth)\n  getUser(id: string): Promise<User | undefined>;\n  upsertUser(user: UpsertUser): Promise<User>;\n  \n  // GDPR Consent Management\n  getAttendeeByConsentToken(token: string): Promise<(Attendee & { meetingId: string }) | null>;\n  updateAttendeeConsent(token: string, consentGiven: boolean): Promise<{ meetingId: string } | null>;\n  updateMeetingConsentStatus(meetingId: string): Promise<void>;\n}\n\nexport class DatabaseStorage implements IStorage {\n  async createMeeting(meeting: InsertMeeting, attendeesList: InsertAttendee[], userId: string): Promise<Meeting> {\n    // Create meeting and attendees in a transaction\n    const result = await db.transaction(async (tx) => {\n      // Insert meeting with userId\n      const [newMeeting] = await tx\n        .insert(meetings)\n        .values({ ...meeting, userId })\n        .returning();\n      \n      // Insert attendees with consent tokens\n      if (attendeesList.length > 0) {\n        await tx\n          .insert(attendees)\n          .values(attendeesList.map(attendee => ({\n            ...attendee,\n            meetingId: newMeeting.id,\n            consentToken: crypto.randomUUID() // Generate unique consent token for each attendee\n          })));\n      }\n      \n      return newMeeting;\n    });\n    \n    return result;\n  }\n\n  async getMeeting(id: string): Promise<Meeting | undefined> {\n    const [meeting] = await db\n      .select()\n      .from(meetings)\n      .where(eq(meetings.id, id));\n    \n    return meeting || undefined;\n  }\n\n  async getMeetingWithAttendees(id: string): Promise<MeetingWithAttendees | undefined> {\n    const meeting = await this.getMeeting(id);\n    if (!meeting) return undefined;\n\n    const meetingAttendees = await db\n      .select()\n      .from(attendees)\n      .where(eq(attendees.meetingId, id));\n\n    const meetingSpeakers = await db\n      .select()\n      .from(speakers)\n      .where(eq(speakers.meetingId, id))\n      .orderBy(speakers.percentage); // Order by speaking time\n\n    return {\n      ...meeting,\n      attendees: meetingAttendees,\n      speakers: meetingSpeakers\n    };\n  }\n\n  async updateMeeting(id: string, updates: Partial<Meeting>): Promise<void> {\n    await db\n      .update(meetings)\n      .set(updates)\n      .where(eq(meetings.id, id));\n  }\n\n  async finishMeeting(id: string): Promise<void> {\n    await this.updateMeeting(id, {\n      status: 'processing',\n      finishedAt: new Date()\n    });\n  }\n\n  async addAudioChunk(chunk: InsertAudioChunk): Promise<AudioChunk> {\n    const [newChunk] = await db\n      .insert(audioChunks)\n      .values(chunk)\n      .returning();\n    \n    return newChunk;\n  }\n\n  async getAudioChunks(meetingId: string): Promise<AudioChunk[]> {\n    return await db\n      .select()\n      .from(audioChunks)\n      .where(eq(audioChunks.meetingId, meetingId))\n      .orderBy(audioChunks.chunkIndex);\n  }\n\n  async incrementChunkCount(meetingId: string): Promise<void> {\n    // This is now handled by adding audio chunks directly\n    // Can be used for updating meeting status if needed\n  }\n\n  // Speaker operations\n  async addSpeakers(meetingId: string, speakersList: InsertSpeaker[]): Promise<Speaker[]> {\n    if (speakersList.length === 0) return [];\n    \n    const newSpeakers = await db\n      .insert(speakers)\n      .values(speakersList.map(speaker => ({\n        ...speaker,\n        meetingId\n      })))\n      .returning();\n    \n    return newSpeakers;\n  }\n\n  async getSpeakers(meetingId: string): Promise<Speaker[]> {\n    return await db\n      .select()\n      .from(speakers)\n      .where(eq(speakers.meetingId, meetingId))\n      .orderBy(speakers.percentage); // Order by speaking time percentage\n  }\n\n  async updateSpeakerName(meetingId: string, speakerId: string, name: string): Promise<void> {\n    await db\n      .update(speakers)\n      .set({ speakerName: name })\n      .where(and(eq(speakers.meetingId, meetingId), eq(speakers.speakerId, speakerId)));\n  }\n\n  // Auto-cleanup operations - returns meetings that could need cleanup (app filters by age)\n  async getMeetingsForCleanup(retentionDays?: number): Promise<Meeting[]> {\n    return await db\n      .select()\n      .from(meetings)\n      .where(\n        and(\n          eq(meetings.autoCleanupEnabled, true),\n          eq(meetings.status, 'completed') // Only cleanup completed meetings\n        )\n      )\n      .orderBy(meetings.createdAt);\n  }\n\n  async cleanupMeeting(meetingId: string): Promise<void> {\n    // This will cascade delete attendees, audio_chunks, and speakers due to foreign keys\n    await db\n      .delete(meetings)\n      .where(eq(meetings.id, meetingId));\n  }\n\n  async updateLastCleanup(meetingId: string): Promise<void> {\n    await db\n      .update(meetings)\n      .set({ lastCleanupAt: new Date() })\n      .where(eq(meetings.id, meetingId));\n  }\n  \n  // User operations (required for Replit Auth)\n  async getUser(id: string): Promise<User | undefined> {\n    const [user] = await db.select().from(users).where(eq(users.id, id));\n    return user || undefined;\n  }\n\n  async upsertUser(userData: UpsertUser): Promise<User> {\n    const [user] = await db\n      .insert(users)\n      .values(userData)\n      .onConflictDoUpdate({\n        target: users.id,\n        set: {\n          email: userData.email,\n          firstName: userData.firstName,\n          lastName: userData.lastName,\n          profileImageUrl: userData.profileImageUrl,\n          updatedAt: new Date(),\n        },\n      })\n      .returning();\n    return user;\n  }\n\n  // GDPR Consent Management Implementation\n  async getAttendeeByConsentToken(token: string): Promise<(Attendee & { meetingId: string }) | null> {\n    const [attendee] = await db\n      .select()\n      .from(attendees)\n      .where(eq(attendees.consentToken, token));\n    \n    return attendee || null;\n  }\n\n  async updateAttendeeConsent(token: string, consentGiven: boolean): Promise<{ meetingId: string } | null> {\n    const timestamp = new Date();\n    \n    return await db.transaction(async (tx) => {\n      // Update attendee consent status\n      const [result] = await tx\n        .update(attendees)\n        .set({\n          consentGiven,\n          consentTimestamp: consentGiven ? timestamp : attendees.consentTimestamp, // Preserve original timestamp\n          consentWithdrawn: !consentGiven,\n          withdrawalTimestamp: !consentGiven ? timestamp : null\n        })\n        .where(eq(attendees.consentToken, token))\n        .returning({ meetingId: attendees.meetingId });\n      \n      if (!result) return null;\n      \n      // GDPR: If consent withdrawn, delete audio data and cleanup temp files\n      if (!consentGiven) {\n        await this.handleConsentWithdrawal(result.meetingId, tx);\n        \n        // Immediate cleanup of temp files (import dynamically to avoid circular deps)\n        try {\n          const { processingService } = await import('./processingService');\n          await processingService.forceCleanupMeetingChunks(result.meetingId);\n        } catch (error) {\n          console.error('Failed to cleanup temp files after consent withdrawal:', error);\n        }\n      }\n      \n      return result;\n    });\n  }\n\n  // GDPR Data Deletion on Consent Withdrawal\n  private async handleConsentWithdrawal(meetingId: string, tx?: any) {\n    const dbConn = tx || db;\n    \n    // Get all audio chunks to delete binary data\n    const chunks = await dbConn\n      .select()\n      .from(audioChunks)\n      .where(eq(audioChunks.meetingId, meetingId));\n    \n    // Delete binary audio data from object storage\n    try {\n      const { AudioStorageService } = await import('./audioStorage');\n      const audioStorageService = new AudioStorageService();\n      \n      for (const chunk of chunks) {\n        if (chunk.objectPath) {\n          await audioStorageService.deleteAudioChunk(chunk.objectPath);\n        }\n      }\n    } catch (error) {\n      console.error('Failed to delete audio binaries from storage:', error);\n      // Continue with DB cleanup even if binary deletion fails\n    }\n    \n    // Delete audio chunk metadata from database\n    await dbConn\n      .delete(audioChunks)\n      .where(eq(audioChunks.meetingId, meetingId));\n    \n    // Clear transcription and summary data\n    await dbConn\n      .update(meetings)\n      .set({\n        transcription: null,\n        summary: null,\n        speakerData: null,\n        status: 'cancelled' // Mark as cancelled due to consent withdrawal\n      })\n      .where(eq(meetings.id, meetingId));\n    \n    // Delete speaker analysis data\n    await dbConn\n      .delete(speakers)\n      .where(eq(speakers.meetingId, meetingId));\n    \n    console.log(`GDPR: Complete data deletion (DB + binaries) for meeting ${meetingId} due to consent withdrawal`);\n  }\n\n  async updateMeetingConsentStatus(meetingId: string): Promise<void> {\n    // Check if all attendees have consented\n    const attendeesList = await db\n      .select()\n      .from(attendees)\n      .where(eq(attendees.meetingId, meetingId));\n    \n    const allConsented = attendeesList.length > 0 && \n      attendeesList.every(attendee => attendee.consentGiven && !attendee.consentWithdrawn);\n    \n    // Update meeting status\n    await db\n      .update(meetings)\n      .set({ allAttendeesConsented: allConsented })\n      .where(eq(meetings.id, meetingId));\n  }\n}\n\nexport const storage = new DatabaseStorage();"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 569, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/simple-auth.ts"],"sourcesContent":["// Temporary simple auth implementation to bypass @hapi/iron dependency issues\nimport { storage } from \"../server/storage\";\nimport { db } from \"../server/db\";\nimport { sessions } from \"../shared/schema\";\nimport { eq, lt } from \"drizzle-orm\";\n\n// Require strong session secret in all environments\nconst SESSION_SECRET = process.env.SESSION_SECRET || \"super-secure-session-secret-key-for-vandelft-groep-ai-notulist-2025\";\nif (!SESSION_SECRET) {\n  throw new Error(\"SESSION_SECRET environment variable is required and must be a strong secret\");\n}\n\n// Simplified session encoding - just use base64 with session ID\nfunction simpleEncode(data: any): string {\n  const payload = JSON.stringify(data);\n  return Buffer.from(payload).toString('base64url');\n}\n\nfunction simpleDecode(token: string): any | null {\n  try {\n    const payload = Buffer.from(token, 'base64url').toString();\n    return JSON.parse(payload);\n  } catch {\n    return null;\n  }\n}\n\n// Session management functions\nexport async function createSession(userId: string): Promise<string> {\n  // Generate 32-char hex string (compatible with short DB columns)\n  const sessionId = Array.from(crypto.getRandomValues(new Uint8Array(16)))\n    .map(b => b.toString(16).padStart(2, '0'))\n    .join('');\n  const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours\n  \n  await db.insert(sessions).values({\n    sid: sessionId,\n    sess: { userId },\n    expire: expiresAt\n  });\n  \n  const sessionData = { sessionId, userId, expiresAt: expiresAt.toISOString() };\n  return simpleEncode(sessionData);\n}\n\nexport async function getSession(token: string): Promise<{ userId: string } | null> {\n  if (!token) return null;\n  \n  const sessionData = simpleDecode(token);\n  if (!sessionData || !sessionData.sessionId) {\n    return null;\n  }\n  \n  // Check if session exists and is valid\n  const [session] = await db\n    .select()\n    .from(sessions)\n    .where(eq(sessions.sid, sessionData.sessionId));\n  \n  if (!session || session.expire < new Date()) {\n    // Clean up expired session\n    if (session) {\n      await db.delete(sessions).where(eq(sessions.sid, sessionData.sessionId));\n    }\n    return null;\n  }\n  \n  const sessData = session.sess as any;\n  return { userId: sessData.userId };\n}\n\nexport async function deleteSession(token: string): Promise<void> {\n  const sessionData = simpleDecode(token);\n  if (sessionData?.sessionId) {\n    await db.delete(sessions).where(eq(sessions.sid, sessionData.sessionId));\n  }\n}\n\n// Clean up expired sessions (called periodically)\nexport async function cleanupExpiredSessions(): Promise<void> {\n  await db.delete(sessions).where(lt(sessions.expire, new Date()));\n}\n\n// Generate auth URL for Replit OAuth (simplified)\nexport function generateAuthUrl(redirectUri: string): string {\n  const state = crypto.randomUUID();\n  const authUrl = new URL(\"https://replit.com/oauth/authorize\");\n  authUrl.searchParams.set(\"client_id\", process.env.REPL_ID || \"\");\n  authUrl.searchParams.set(\"redirect_uri\", redirectUri);\n  authUrl.searchParams.set(\"response_type\", \"code\");\n  authUrl.searchParams.set(\"scope\", \"user:email\");\n  authUrl.searchParams.set(\"state\", state);\n  \n  return authUrl.toString();\n}\n\n// Exchange code for user info (simplified - would need full OAuth implementation)\nexport async function exchangeCodeForUser(code: string): Promise<any> {\n  // This is a simplified version - in production you'd need full OAuth flow\n  // For now, return a mock user for testing\n  console.log(\"Auth code received:\", code);\n  return {\n    id: \"temp-user-\" + Math.random().toString(36).substr(2, 9),\n    email: \"test@example.com\",\n    name: \"Test User\"\n  };\n}\n\n// Compatibility function for authMiddleware.ts\nexport async function getUserFromSession(token: string): Promise<{ user: any } | null> {\n  const session = await getSession(token);\n  if (!session) return null;\n  \n  // Get user data from storage\n  const user = await storage.getUser(session.userId);\n  if (!user) return null;\n  \n  return { user };\n}\n\n// Additional auth functions for compatibility\nexport function generateLogoutUrl(): string {\n  return \"/api/auth/logout\";\n}\n\nexport function encryptSessionId(sessionData: any): string {\n  return simpleEncode(sessionData);\n}\n\nexport function decryptSessionId(token: string): any {\n  return simpleDecode(token);\n}\n\nexport async function handleCallback(code: string): Promise<{ sessionToken: string; user: any }> {\n  const userData = await exchangeCodeForUser(code);\n  \n  // Upsert user in database\n  const user = await storage.upsertUser({\n    id: userData.id,\n    email: userData.email,\n    firstName: userData.name?.split(' ')[0] || '',\n    lastName: userData.name?.split(' ').slice(1).join(' ') || ''\n  });\n  \n  // Create session\n  const sessionToken = await createSession(user.id);\n  \n  return { sessionToken, user };\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 725, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/debug-auth/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getSession } from '../../../lib/simple-auth';\n\nexport async function GET(req: NextRequest) {\n  try {\n    // Debug cookie parsing\n    const cookieHeader = req.headers.get('cookie');\n    console.log('DEBUG: Cookie header:', cookieHeader);\n    \n    let sessionToken = req.cookies.get('session-token')?.value;\n    console.log('DEBUG: Token from req.cookies:', sessionToken?.substring(0, 50) + '...');\n    \n    if (!sessionToken && cookieHeader) {\n      const match = cookieHeader.match(/session-token=([^;]+)/);\n      if (match) {\n        sessionToken = decodeURIComponent(match[1]);\n        console.log('DEBUG: Token from header match:', sessionToken?.substring(0, 50) + '...');\n      }\n    }\n    \n    if (!sessionToken) {\n      return NextResponse.json({\n        error: 'No session token found',\n        cookieHeader,\n        cookies: Object.fromEntries(req.cookies.getAll().map(c => [c.name, c.value?.substring(0, 50) + '...']))\n      });\n    }\n    \n    console.log('DEBUG: Validating session...');\n    const sessionData = await getSession(sessionToken);\n    console.log('DEBUG: Session validation result:', sessionData);\n    \n    return NextResponse.json({\n      success: true,\n      sessionValid: !!sessionData,\n      sessionData,\n      tokenLength: sessionToken.length\n    });\n    \n  } catch (error) {\n    console.error('DEBUG: Error:', error);\n    return NextResponse.json({\n      error: 'Debug failed',\n      message: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,IAAI,GAAgB;IACxC,IAAI;QACF,uBAAuB;QACvB,MAAM,eAAe,IAAI,OAAO,CAAC,GAAG,CAAC;QACrC,QAAQ,GAAG,CAAC,yBAAyB;QAErC,IAAI,eAAe,IAAI,OAAO,CAAC,GAAG,CAAC,kBAAkB;QACrD,QAAQ,GAAG,CAAC,kCAAkC,cAAc,UAAU,GAAG,MAAM;QAE/E,IAAI,CAAC,gBAAgB,cAAc;YACjC,MAAM,QAAQ,aAAa,KAAK,CAAC;YACjC,IAAI,OAAO;gBACT,eAAe,mBAAmB,KAAK,CAAC,EAAE;gBAC1C,QAAQ,GAAG,CAAC,mCAAmC,cAAc,UAAU,GAAG,MAAM;YAClF;QACF;QAEA,IAAI,CAAC,cAAc;YACjB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,OAAO;gBACP;gBACA,SAAS,OAAO,WAAW,CAAC,IAAI,OAAO,CAAC,MAAM,GAAG,GAAG,CAAC,CAAA,IAAK;wBAAC,EAAE,IAAI;wBAAE,EAAE,KAAK,EAAE,UAAU,GAAG,MAAM;qBAAM;YACvG;QACF;QAEA,QAAQ,GAAG,CAAC;QACZ,MAAM,cAAc,MAAM,IAAA,qIAAU,EAAC;QACrC,QAAQ,GAAG,CAAC,qCAAqC;QAEjD,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,cAAc,CAAC,CAAC;YAChB;YACA,aAAa,aAAa,MAAM;QAClC;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iBAAiB;QAC/B,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD;IACF;AACF","debugId":null}}]
}